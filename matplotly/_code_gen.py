"""Generate Python code from the current figure state."""
from __future__ import annotations

from typing import Any

import numpy as np
from matplotlib.colors import to_hex
from matplotlib.figure import Figure
from matplotlib.lines import Line2D

from ._commands import CommandStack


def generate_code(fig: Figure, stack: CommandStack) -> str:
    """Produce a Python code snippet reproducing the figure's current styling.

    Emits style modifications that apply on top of the user's original
    plotting code.  For distribution plots (boxplot/violinplot), emits
    ax.bxp() calls with compact statistics and styling kwargs.
    """
    all_axes = fig.get_axes()
    # Separate main axes from marginal histogram and colorbar axes
    axes_list = [a for a in all_axes
                 if not getattr(a, '_matplotly_marginal', False)
                 and not hasattr(a, '_colorbar')]
    marginal_axes = [a for a in all_axes if getattr(a, '_matplotly_marginal', False)]

    if not axes_list:
        return "# No axes found."

    multi = len(axes_list) > 1

    lines: list[str] = ["# Generated by matplotly v4"]

    if multi:
        lines.append("axes = fig.get_axes()")

    for ax_i, ax in enumerate(axes_list):
        ax_var = f"axes[{ax_i}]" if multi else "ax"

        # --- Identify distribution-managed artists (for skip logic) ---
        dist_artist_ids: set[int] = set()
        _dist_infos = getattr(ax, '_matplotly_dist_info', [])
        has_dist = bool(_dist_infos)

        # --- Identify heatmap-managed artists (for skip logic) ---
        heatmap_artist_ids: set[int] = set()
        for _hi in getattr(ax, '_matplotly_heatmap_info', []):
            m = _hi.get('mappable')
            if m is not None:
                heatmap_artist_ids.add(id(m))

        if has_dist:
            for art in ax.lines:
                if art.get_label().startswith("_"):
                    dist_artist_ids.add(id(art))
            for coll in ax.collections:
                if getattr(coll, '_matplotly_dist', False):
                    dist_artist_ids.add(id(coll))
                if getattr(coll, '_matplotly_dist_jitter', False):
                    dist_artist_ids.add(id(coll))
            for patch in ax.patches:
                if getattr(patch, '_matplotly_dist', False):
                    dist_artist_ids.add(id(patch))

        # --- Identify errorbar-managed artists (for skip logic) ---
        errorbar_artist_ids: set[int] = set()
        for l in ax.lines:
            if getattr(l, '_matplotly_errorbar', False):
                errorbar_artist_ids.add(id(l))
            if getattr(l, '_matplotly_bar_errorbar', False):
                errorbar_artist_ids.add(id(l))
        for coll in ax.collections:
            if getattr(coll, '_matplotly_errorbar', False):
                errorbar_artist_ids.add(id(coll))
            if getattr(coll, '_matplotly_bar_errorbar', False):
                errorbar_artist_ids.add(id(coll))

        # --- Lines (filtered list for stable indexing) ---
        _user_lines = [l for l in ax.lines
                       if not l.get_label().startswith("_")
                       and id(l) not in errorbar_artist_ids]
        if _user_lines:
            lines.append(
                f"\n_lines = [l for l in {ax_var}.lines "
                f"if not l.get_label().startswith('_')]")
        for j, line in enumerate(_user_lines):
            label = line.get_label()
            acc = f"_lines[{j}]"
            lines.append(f"\n# {label or f'Line {j}'}")
            lines.append(f"{acc}.set_color({_fmt(to_hex(line.get_color()))})")
            lines.append(f"{acc}.set_linewidth({_fmt(line.get_linewidth())})")
            ls = line.get_linestyle()
            if ls != "-":
                lines.append(f"{acc}.set_linestyle({_fmt(ls)})")
            alpha = line.get_alpha()
            if alpha is not None and alpha != 1.0:
                lines.append(f"{acc}.set_alpha({_fmt(alpha)})")
            marker = line.get_marker()
            if marker and marker != "None" and marker != "none":
                lines.append(f"{acc}.set_marker({_fmt(marker)})")
                lines.append(f"{acc}.set_markersize({_fmt(line.get_markersize())})")

        # --- Histograms ---
        hist_patch_ids: set[int] = set()
        hist_container_idxs: list[int] = []
        from matplotlib.container import BarContainer as _BCt
        from matplotlib.patches import Rectangle as _Rect

        # Build BarContainer-only index list (excludes ErrorbarContainers)
        _all_bc_idxs = [ci for ci, _c in enumerate(ax.containers)
                        if isinstance(_c, _BCt)]

        _hist_infos = getattr(ax, '_matplotly_hist_info', [])
        _hist_merged = any(hi.get('merged', False) for hi in _hist_infos)
        _skip_hist_style = False
        _need_bar_cs = False  # whether to emit _bar_cs filter in output

        if _hist_infos and _hist_merged:
            # Merged: all BarContainers are histogram containers
            for ci, _c in enumerate(ax.containers):
                if isinstance(_c, _BCt):
                    hist_container_idxs.append(ci)
                    for _p in _c:
                        hist_patch_ids.add(id(_p))
            for hi in _hist_infos:
                for art in hi.get('artists', []):
                    hist_patch_ids.add(id(art))
            _data_vars = getattr(ax, '_matplotly_hist_data_vars', None)
            _skip_hist_style = _emit_hist_merged(
                lines, ax_var, _hist_infos, data_vars=_data_vars)
        else:
            # Non-merged: detect histograms via geometry or attribute
            for ci, _c in enumerate(ax.containers):
                if isinstance(_c, _BCt):
                    from ._introspect import FigureIntrospector as _FI_cg
                    if (_FI_cg._is_histogram_container(_c)
                            or getattr(_c, '_matplotly_is_histogram', False)):
                        hist_container_idxs.append(ci)
                        for _p in _c:
                            hist_patch_ids.add(id(_p))

        if not _skip_hist_style:
            # Build label lookup from hist_info
            _hi_label_map = {}
            for _hi in _hist_infos:
                _hi_arts = _hi.get('artists', [])
                if _hi_arts:
                    _hi_label_map[id(_hi_arts[0])] = _hi.get('label', '')

            # Style-only code for all detected histogram containers
            for _hj, _hci in enumerate(hist_container_idxs):
                _hcont = ax.containers[_hci]
                _hpats = [p for p in _hcont.patches
                          if isinstance(p, _Rect)]
                if not _hpats:
                    continue
                _hp0 = _hpats[0]
                _hlbl = _hi_label_map.get(id(_hp0), '')
                if not _hlbl or _hlbl.startswith("_"):
                    _hlbl = _hp0.get_label()
                if not _hlbl or _hlbl.startswith("_"):
                    _hlbl = _hcont.get_label()
                if not _hlbl or _hlbl.startswith("_"):
                    _hlbl = f"Histogram {_hj}"
                _hfc = to_hex(_hp0.get_facecolor())
                _hec = to_hex(_hp0.get_edgecolor())
                _halpha = _hp0.get_alpha()
                _hlw = _hp0.get_linewidth()

                # Use BarContainer-relative index for robustness
                _h_bc_idx = (_all_bc_idxs.index(_hci)
                             if _hci in _all_bc_idxs else _hci)
                if not _need_bar_cs:
                    lines.append(
                        "\nfrom matplotlib.container import "
                        "BarContainer as _BC")
                    lines.append(
                        f"_bar_cs = [c for c in {ax_var}.containers "
                        f"if isinstance(c, _BC)]")
                    _need_bar_cs = True

                lines.append(f"\n# Histogram: {_hlbl}")
                _hacc = f"_bar_cs[{_h_bc_idx}]"
                lines.append(f"for _p in {_hacc}:")
                lines.append(f"    _p.set_facecolor({_fmt(_hfc)})")
                lines.append(f"    _p.set_edgecolor({_fmt(_hec)})")
                if _halpha is not None and round(_halpha, 2) != 1.0:
                    lines.append(
                        f"    _p.set_alpha({_fmt(round(_halpha, 2))})")
                if round(_hlw, 1) != 1.0:
                    lines.append(
                        f"    _p.set_linewidth({_fmt(round(_hlw, 1))})")
                _hhatch = _hp0.get_hatch()
                if _hhatch:
                    lines.append(f"    _p.set_hatch({_fmt(_hhatch)})")

        # --- Bars (style existing containers) ---
        bar_patch_ids: set[int] = set()
        bar_container_idxs: list[int] = []
        # bar_bc_rel_idxs: position of each bar within BarContainer-only list
        bar_bc_rel_idxs: list[int] = []
        for ci, _c in enumerate(ax.containers):
            if isinstance(_c, _BCt) and ci not in hist_container_idxs:
                bar_container_idxs.append(ci)
                bar_bc_rel_idxs.append(
                    _all_bc_idxs.index(ci) if ci in _all_bc_idxs else ci)
                for _p in _c:
                    bar_patch_ids.add(id(_p))

        for _bj, _bci in enumerate(bar_container_idxs):
            _bcont = ax.containers[_bci]
            _bpats = [p for p in _bcont.patches if isinstance(p, _Rect)]
            if not _bpats:
                continue
            _bp0 = _bpats[0]
            _blbl = _bcont.get_label()
            if not _blbl or _blbl.startswith("_"):
                _blbl = _bp0.get_label()
            if not _blbl or _blbl.startswith("_"):
                _blbl = f"Bar group {_bj}"

            _bfc = to_hex(_bp0.get_facecolor())
            _bec = to_hex(_bp0.get_edgecolor())
            _balpha = _bp0.get_alpha()
            _blw = _bp0.get_linewidth()

            # Emit BarContainer filter if not yet done
            if not _need_bar_cs:
                lines.append(
                    "\nfrom matplotlib.container import "
                    "BarContainer as _BC")
                lines.append(
                    f"_bar_cs = [c for c in {ax_var}.containers "
                    f"if isinstance(c, _BC)]")
                _need_bar_cs = True

            _b_rel_idx = bar_bc_rel_idxs[_bj]
            lines.append(f"\n# {_blbl}")
            _bacc = f"_bar_cs[{_b_rel_idx}]"
            lines.append(f"for _p in {_bacc}:")
            lines.append(f"    _p.set_facecolor({_fmt(_bfc)})")
            lines.append(f"    _p.set_edgecolor({_fmt(_bec)})")
            if _balpha is not None and round(_balpha, 2) != 1.0:
                lines.append(
                    f"    _p.set_alpha({_fmt(round(_balpha, 2))})")
            if round(_blw, 1) != 1.0:
                lines.append(
                    f"    _p.set_linewidth({_fmt(round(_blw, 1))})")
            _bhatch = _bp0.get_hatch()
            if _bhatch:
                lines.append(f"    _p.set_hatch({_fmt(_bhatch)})")

            # Per-patch geometry (width + position)
            _bi_orient = (getattr(ax, '_matplotly_bar_info', [{}])[0]
                          .get('orientation', 'vertical')
                          if getattr(ax, '_matplotly_bar_info', None)
                          else 'vertical')
            _b_vert = _bi_orient == 'vertical'
            if _b_vert:
                _bw_cur = round(float(_bp0.get_width()), 4)
                _bx_list = [round(float(p.get_x()), 4) for p in _bpats]
                lines.append(
                    f"for _p, _x in zip({_bacc}, {_bx_list!r}):")
                lines.append(f"    _p.set_width({_fmt(_bw_cur)})")
                lines.append(f"    _p.set_x(_x)")
            else:
                _bh_cur = round(float(_bp0.get_height()), 4)
                _by_list = [round(float(p.get_y()), 4) for p in _bpats]
                lines.append(
                    f"for _p, _y in zip({_bacc}, {_by_list!r}):")
                lines.append(f"    _p.set_height({_fmt(_bh_cur)})")
                lines.append(f"    _p.set_y(_y)")

        # Bar tick labels (from bar panel adjustments)
        _bar_infos = getattr(ax, '_matplotly_bar_info', [])
        if _bar_infos:
            _bi_ref = _bar_infos[0]
            _bi_tl = _bi_ref.get('tick_labels', [])
            _bi_tc = _bi_ref.get('tick_centers', [])
            _bi_orient = _bi_ref.get('orientation', 'vertical')
            if _bi_tl and _bi_tc:
                _bi_tax = 'x' if _bi_orient == 'vertical' else 'y'
                _bi_tc_str = ", ".join(
                    str(round(float(t), 4)) for t in _bi_tc)
                lines.append(
                    f"{ax_var}.set_{_bi_tax}ticks([{_bi_tc_str}])")
                _bi_rot = _bi_ref.get('tick_rotation', 0)
                _bi_ha = _bi_ref.get('tick_ha', 'center')
                _bi_tl_args = f"{_bi_tl!r}"
                if _bi_rot:
                    _bi_tl_args += f", rotation={_fmt(_bi_rot)}"
                if _bi_ha != "center":
                    _bi_tl_args += f", ha={_fmt(_bi_ha)}"
                    _bi_tl_args += ", rotation_mode='anchor'"
                lines.append(
                    f"{ax_var}.set_{_bi_tax}ticklabels({_bi_tl_args})")

        # --- Bar error bars ---
        if _bar_infos:
            _emit_bar_errorbars(
                lines, ax_var, _bar_infos, bar_bc_rel_idxs,
                _need_bar_cs)

        # --- Distribution plots (bxp-based recreation) ---
        _dist_data_vars = getattr(ax, '_matplotly_dist_data_vars', None)

        if _dist_infos:
            _di_ref = _dist_infos[0]
            _di_orient = _di_ref.get('orientation', 'vertical')
            _di_width = _di_ref.get('width', 0.5)
            _di_tl = _di_ref.get('tick_labels', [])
            _di_tc = _di_ref.get('tick_centers',
                                  _di_ref.get('positions', []))
            _di_ng = len(_dist_infos)

            if _dist_data_vars:
                # --- Apply path: use real data variable ---
                _emit_dist_with_data(
                    lines, ax_var, _dist_infos, _dist_data_vars,
                    _di_orient, _di_width, _di_ng)
            else:
                # --- Copy/fallback path: stats + fabricated data ---
                lines.append(f"\n# Distribution plot")

                # Cleanup original distribution artists so bxp() doesn't double
                lines.append(
                    f"for _l in list({ax_var}.lines):")
                lines.append(
                    f"    if _l.get_label().startswith('_'):")
                lines.append(
                    f"        _l.remove()")
                lines.append(
                    f"for _p in list({ax_var}.patches):")
                lines.append(
                    f"    if _p.get_label() == '' or _p.get_label().startswith('_'):")
                lines.append(
                    f"        try:")
                lines.append(
                    f"            _p.remove()")
                lines.append(
                    f"        except ValueError:")
                lines.append(
                    f"            pass")

                for _dj, _dinfo in enumerate(_dist_infos):
                    _d_mode = _dinfo.get('display_mode', 'box')
                    _d_label = _dinfo.get('label', f'Group {_dj}')
                    _d_pos = _dinfo.get('positions', _di_tc)
                    _d_raw = _dinfo.get('raw_data', [])

                    lines.append(f"\n# {_d_label}")

                    if not _d_raw:
                        continue

                    # Prefer original introspected stats (avoids double
                    # reconstruction that degrades violin KDE shapes).
                    _orig_box_stats = _dinfo.get('box_stats', [])
                    if _orig_box_stats:
                        bxp_stats = _bxp_stats_from_original(
                            _orig_box_stats, _dinfo)
                    else:
                        bxp_stats = _compute_bxp_stats(_d_raw, _dinfo)
                    if not bxp_stats:
                        continue
                    svar = _emit_stats_var(lines, bxp_stats, _dj, _di_ng)

                    # Reconstruct data from stats for violin/jitter
                    _needs_data = 'violin' in _d_mode or 'jitter' in _d_mode
                    raw_var = None
                    if _needs_data:
                        raw_var = _emit_data_from_stats(
                            lines, svar, _dj, _di_ng)

                    # Violin (background layer)
                    if 'violin' in _d_mode and raw_var:
                        _emit_violin(lines, ax_var, _dinfo, raw_var, _d_pos,
                                     _di_orient, _di_width, _d_mode,
                                     _d_label)

                    # Box (middle layer)
                    if 'box' in _d_mode:
                        _emit_bxp_call(lines, ax_var, _dinfo, svar, _d_pos,
                                       _d_label, _dj, _di_ng, _di_orient,
                                       _di_width, _d_mode)

                    # Jitter (top layer)
                    if 'jitter' in _d_mode and raw_var:
                        _emit_jitter(lines, ax_var, _dinfo, raw_var, _d_pos,
                                     _di_orient, _d_mode, _d_label)

            # Tick labels (shared by both paths)
            if _di_tl and _di_tc:
                _d_tax = 'x' if _di_orient == 'vertical' else 'y'
                _d_tc_str = ", ".join(
                    str(round(float(t), 4)) for t in _di_tc)
                lines.append(
                    f"\n{ax_var}.set_{_d_tax}ticks([{_d_tc_str}])")
                _d_ha = _di_ref.get('tick_ha', 'center')
                _d_rot = _di_ref.get('tick_rotation', 0)
                _d_pad = _di_ref.get('tick_pad', 4.0)
                _d_tl_args = f"{_di_tl!r}"
                if _d_rot:
                    _d_tl_args += f", rotation={_fmt(_d_rot)}"
                if _d_ha != 'center':
                    _d_tl_args += f", ha={_fmt(_d_ha)}"
                    _d_tl_args += ", rotation_mode='anchor'"
                lines.append(
                    f"{ax_var}.set_{_d_tax}ticklabels({_d_tl_args})")
                if abs(_d_pad - 4.0) > 0.1:
                    lines.append(
                        f"{ax_var}.tick_params(axis={_fmt(_d_tax)},"
                        f" pad={_fmt(_d_pad)})")

        # --- Heatmaps ---
        _heatmap_infos = getattr(ax, '_matplotly_heatmap_info', [])
        if _heatmap_infos:
            _emit_heatmap(lines, ax_var, _heatmap_infos)

        # --- Colorbar ---
        _cbar_info = getattr(ax, '_matplotly_colorbar_info', None)
        if _cbar_info and _cbar_info.get('show', False) and _heatmap_infos:
            _emit_colorbar(lines, ax_var, _cbar_info, _heatmap_infos)

        # --- Errorbars ---
        _errorbar_infos = getattr(ax, '_matplotly_errorbar_info', [])
        if _errorbar_infos:
            _emit_errorbars(lines, ax_var, _errorbar_infos)

        # --- Patches (generic — skip histogram + bar + dist patches) ---
        _skip_ids = hist_patch_ids | bar_patch_ids | dist_artist_ids
        for i, patch in enumerate(ax.patches):
            if id(patch) in _skip_ids:
                continue
            if hasattr(patch, "get_facecolor"):
                fc = to_hex(patch.get_facecolor())
                if fc != "#1f77b4":  # only if non-default
                    acc = f"{ax_var}.patches[{i}]"
                    lines.append(f"{acc}.set_facecolor({_fmt(fc)})")

        # --- Collections (scatter — filtered list for stable indexing) ---
        from matplotlib.collections import PathCollection
        _user_colls = []
        for coll in ax.collections:
            if not isinstance(coll, PathCollection):
                continue
            if id(coll) in dist_artist_ids:
                continue
            if id(coll) in heatmap_artist_ids:
                continue
            if id(coll) in errorbar_artist_ids:
                continue
            _user_colls.append(coll)

        if _user_colls:
            lines.append(
                f"\nfrom matplotlib.collections import "
                f"PathCollection as _PC")
            lines.append(
                f"_scatter = [c for c in {ax_var}.collections "
                f"if isinstance(c, _PC)]")
        for j, coll in enumerate(_user_colls):
            acc = f"_scatter[{j}]"
            try:
                fc = coll.get_facecolor()
                if len(fc) > 0:
                    lines.append(
                        f"{acc}.set_facecolor({_fmt(to_hex(fc[0]))})")
                ec = coll.get_edgecolor()
                if len(ec) > 0:
                    _ec_hex = to_hex(ec[0])
                    if _ec_hex != "#000000":
                        lines.append(
                            f"{acc}.set_edgecolor({_fmt(_ec_hex)})")
                alpha = coll.get_alpha()
                if alpha is not None:
                    lines.append(f"{acc}.set_alpha({_fmt(alpha)})")
                sizes = coll.get_sizes()
                if len(sizes) > 0:
                    lines.append(
                        f"{acc}.set_sizes([{_fmt(float(sizes[0]))}])")
            except Exception:
                pass

        # --- Text labels ---
        title = ax.get_title()
        xlabel = ax.get_xlabel()
        ylabel = ax.get_ylabel()
        if title or xlabel or ylabel:
            lines.append(f"\n# Labels")
            if title:
                lines.append(f"{ax_var}.set_title({_fmt(title)})")
            if xlabel:
                lines.append(f"{ax_var}.set_xlabel({_fmt(xlabel)})")
            if ylabel:
                lines.append(f"{ax_var}.set_ylabel({_fmt(ylabel)})")

        # --- Axis limits ---
        xlim = ax.get_xlim()
        ylim = ax.get_ylim()
        lines.append(f"\n# Limits")
        lines.append(f"{ax_var}.set_xlim({_fmt(round(float(xlim[0]), 4))}, "
                     f"{_fmt(round(float(xlim[1]), 4))})")
        lines.append(f"{ax_var}.set_ylim({_fmt(round(float(ylim[0]), 4))}, "
                     f"{_fmt(round(float(ylim[1]), 4))})")

        # --- Axis scale ---
        xscale = ax.get_xscale()
        yscale = ax.get_yscale()
        if xscale != "linear" or yscale != "linear":
            lines.append(f"\n# Scale")
            if xscale != "linear":
                lines.append(f"{ax_var}.set_xscale({_fmt(xscale)})")
            if yscale != "linear":
                lines.append(f"{ax_var}.set_yscale({_fmt(yscale)})")

        # --- Fonts ---
        title_size = ax.title.get_fontsize()
        xlabel_size = ax.xaxis.label.get_fontsize()
        ylabel_size = ax.yaxis.label.get_fontsize()
        title_family = ax.title.get_fontfamily()
        if isinstance(title_family, list):
            title_family = title_family[0] if title_family else "Arial"

        lines.append(f"\n# Fonts")
        lines.append(f"{ax_var}.title.set_fontsize({_fmt(title_size)})")
        lines.append(f"{ax_var}.title.set_fontfamily({_fmt(title_family)})")
        lines.append(f"{ax_var}.xaxis.label.set_fontsize({_fmt(xlabel_size)})")
        lines.append(f"{ax_var}.yaxis.label.set_fontsize({_fmt(ylabel_size)})")

        # Title pad (distance from axes top, in points)
        try:
            _tpad_disp = ax.titleOffsetTrans.get_matrix()[1, 2]
            _tpad_pts = round(_tpad_disp / fig.dpi * 72, 1)
            if abs(_tpad_pts - 6.0) > 0.5:
                lines.append(
                    f"{ax_var}.set_title({ax_var}.get_title(), "
                    f"pad={_fmt(_tpad_pts)})")
        except Exception:
            pass

        # Text color / weight / style
        for _tname, _tobj in [("title", ax.title),
                               ("xaxis.label", ax.xaxis.label),
                               ("yaxis.label", ax.yaxis.label)]:
            try:
                _tc = to_hex(_tobj.get_color())
                if _tc != "#000000":
                    lines.append(f"{ax_var}.{_tname}.set_color({_fmt(_tc)})")
            except Exception:
                pass
            _fw = _tobj.get_fontweight()
            if _fw == 'bold' or (isinstance(_fw, (int, float)) and _fw >= 600):
                lines.append(f"{ax_var}.{_tname}.set_fontweight('bold')")
            if _tobj.get_fontstyle() == 'italic':
                lines.append(f"{ax_var}.{_tname}.set_fontstyle('italic')")

        # Tick label font size (use first tick as representative)
        xticks = ax.get_xticklabels()
        yticks = ax.get_yticklabels()
        if xticks:
            tick_sz = xticks[0].get_fontsize()
            lines.append(f"{ax_var}.tick_params(labelsize={_fmt(tick_sz)})")

        # Tick label colors
        _xtl = ax.get_xticklabels()
        if _xtl:
            try:
                _xtc = to_hex(_xtl[0].get_color())
                if _xtc != "#000000":
                    lines.append(f"{ax_var}.tick_params(axis='x', "
                                 f"labelcolor={_fmt(_xtc)})")
            except Exception:
                pass
        _ytl = ax.get_yticklabels()
        if _ytl:
            try:
                _ytc = to_hex(_ytl[0].get_color())
                if _ytc != "#000000":
                    lines.append(f"{ax_var}.tick_params(axis='y', "
                                 f"labelcolor={_fmt(_ytc)})")
            except Exception:
                pass

        # --- Tick params ---
        # Read from the actual tick objects
        xtick_objs = ax.xaxis.get_major_ticks()
        if xtick_objs:
            tick = xtick_objs[0]
            tick_line = tick.tick1line
            direction = "in" if tick_line.get_marker() == 2 else "out"
            # Check inout: tick2line visible means inout
            if tick.tick2line.get_visible() and not ax.spines["top"].get_visible():
                direction = "inout"
            tick_len = tick_line.get_markersize()
            tick_width = tick_line.get_markeredgewidth()
            lines.append(f"{ax_var}.tick_params(direction={_fmt(direction)}, "
                         f"length={_fmt(tick_len)}, width={_fmt(tick_width)})")

        # --- Tick spacing ---
        from matplotlib.ticker import MultipleLocator as _ML
        x_loc = ax.xaxis.get_major_locator()
        y_loc = ax.yaxis.get_major_locator()
        if isinstance(x_loc, _ML) or isinstance(y_loc, _ML):
            if isinstance(x_loc, _ML):
                xt = list(ax.get_xticks())
                if len(xt) >= 2:
                    step = round(xt[1] - xt[0], 6)
                    if step > 0:
                        lines.append(
                            f"{ax_var}.xaxis.set_major_locator("
                            f"matplotlib.ticker.MultipleLocator({_fmt(step)}))")
            if isinstance(y_loc, _ML):
                yt = list(ax.get_yticks())
                if len(yt) >= 2:
                    step = round(yt[1] - yt[0], 6)
                    if step > 0:
                        lines.append(
                            f"{ax_var}.yaxis.set_major_locator("
                            f"matplotlib.ticker.MultipleLocator({_fmt(step)}))")

        # --- Spines ---
        spine_changes = []
        for name in ("top", "right", "bottom", "left"):
            sp = ax.spines[name]
            if not sp.get_visible():
                spine_changes.append(
                    f"{ax_var}.spines[{_fmt(name)}].set_visible(False)")
            lw = sp.get_linewidth()
            if lw != 1.0:
                spine_changes.append(
                    f"{ax_var}.spines[{_fmt(name)}].set_linewidth({_fmt(lw)})")
        if spine_changes:
            lines.append(f"\n# Spines")
            lines.extend(spine_changes)

        # --- Grid ---
        # Check if grid lines are visible
        has_grid = any(gl.get_visible() for gl in ax.xaxis.get_gridlines())
        if has_grid:
            gl = ax.xaxis.get_gridlines()[0]
            lines.append(f"\n# Grid")
            lines.append(
                f"{ax_var}.grid(True, alpha={_fmt(gl.get_alpha() or 0.5)}, "
                f"linewidth={_fmt(gl.get_linewidth())}, "
                f"linestyle={_fmt(gl.get_linestyle())})")

        # --- Legend ---
        leg = ax.get_legend()
        _leg_handles, _leg_labels = ax.get_legend_handles_labels()
        if leg is None and _leg_handles:
            # Legend was removed by user
            lines.append(f"\n# Legend removed")
            lines.append(f"if {ax_var}.get_legend() is not None:")
            lines.append(f"    {ax_var}.get_legend().remove()")
        elif leg is not None:
            if _leg_handles:
                lines.append(f"\n# Legend")

                # Get legend properties
                leg_kwargs = []
                try:
                    loc = leg._loc
                    _loc_names = {
                        0: "upper right", 1: "upper right", 2: "upper left",
                        3: "lower left", 4: "lower right", 5: "right",
                        6: "center left", 7: "center right",
                        8: "lower center", 9: "upper center", 10: "center",
                    }
                    loc_str = _loc_names.get(loc, "upper right")
                    leg_kwargs.append(f"loc={_fmt(loc_str)}")
                except Exception:
                    pass

                frameon = leg.get_frame().get_visible()
                leg_kwargs.append(f"frameon={_fmt(frameon)}")

                fontsize = leg._fontsize
                if fontsize:
                    leg_kwargs.append(f"fontsize={_fmt(fontsize)}")

                ncols = leg._ncols
                if ncols != 1:
                    leg_kwargs.append(f"ncol={_fmt(ncols)}")

                markerfirst = getattr(leg, '_markerfirst', True)
                if not markerfirst:
                    leg_kwargs.append("markerfirst=False")

                handletextpad = getattr(leg, 'handletextpad', 0.8)
                if round(handletextpad, 2) != 0.8:
                    leg_kwargs.append(f"handletextpad={_fmt(round(handletextpad, 2))}")

                handleheight = getattr(leg, 'handleheight', 0.7)
                if round(handleheight, 2) != 0.7:
                    leg_kwargs.append(f"handleheight={_fmt(round(handleheight, 2))}")

                # bbox_to_anchor
                if hasattr(leg, "_bbox_to_anchor") and leg._bbox_to_anchor is not None:
                    try:
                        bbox = leg._bbox_to_anchor
                        if bbox.width < 1 and bbox.height < 1:
                            inv = ax.transAxes.inverted()
                            x_ax, y_ax = inv.transform((bbox.x0, bbox.y0))
                            leg_kwargs.append(
                                f"bbox_to_anchor=({_fmt(round(x_ax, 2))}, "
                                f"{_fmt(round(y_ax, 2))})")
                    except Exception:
                        pass

                kwargs_str = ", ".join(leg_kwargs)
                lines.append(f"{ax_var}.legend({kwargs_str})")

                # Legend text colors
                for _li, _lt in enumerate(leg.get_texts()):
                    try:
                        _ltc = to_hex(_lt.get_color())
                        if _ltc != "#000000":
                            lines.append(
                                f"{ax_var}.get_legend().get_texts()"
                                f"[{_li}].set_color({_fmt(_ltc)})")
                    except Exception:
                        pass

    # --- Layout (figure-level, emitted once) ---
    w, h = fig.get_size_inches()
    lines.append(f"\n# Layout")
    lines.append(f"fig.set_size_inches({_fmt(round(w, 2))}, {_fmt(round(h, 2))})")

    fc = to_hex(fig.get_facecolor())
    if fc != "#ffffff":
        lines.append(f"fig.set_facecolor({_fmt(fc)})")

    lines.append(f"fig.tight_layout()")

    # --- Subplot spacing (multi-subplot only) ---
    if multi:
        try:
            sp = fig.subplotpars
            _h = round(sp.hspace, 2) if sp.hspace else 0.0
            _w = round(sp.wspace, 2) if sp.wspace else 0.0
            if _h > 0 or _w > 0:
                lines.append(f"fig.subplots_adjust(hspace={_fmt(_h)}, wspace={_fmt(_w)})")
        except Exception:
            pass

    # --- Marginal histograms ---
    if marginal_axes:
        lines.append("\n# Marginal histograms")

        # Pre-scan: determine space needed per parent axes
        _marg_infos = []  # (m_ax, info) pairs
        _parent_space: dict[int, list] = {}  # pidx -> [(axis, pos, height, pad)]
        for m_ax in marginal_axes:
            info = getattr(m_ax, '_matplotly_marginal_info', None)
            if not info:
                continue
            _marg_infos.append((m_ax, info))
            pidx = info.get('parent_ax_index', 0)
            axis = info.get('axis', 'x')
            position = info.get('position', 'top' if axis == 'x' else 'right')
            m_height = info.get('height', 0.8)
            m_pad = info.get('pad', 0.05)
            _parent_space.setdefault(pidx, []).append(
                (axis, position, m_height, m_pad))

        # Shrink parent axes to make room for marginals
        for pidx, needs in sorted(_parent_space.items()):
            p_var = f"axes[{pidx}]" if multi else "ax"
            lines.append(f"_pos = {p_var}.get_position()")
            lines.append("_fig_w, _fig_h = fig.get_size_inches()")
            lines.append(
                "_x0, _y0, _w, _h = _pos.x0, _pos.y0, "
                "_pos.width, _pos.height")
            for axis, position, m_height, m_pad in needs:
                if axis == 'x' and position == 'top':
                    lines.append(
                        f"_h -= ({_fmt(m_height)} + {_fmt(m_pad)}) / _fig_h")
                elif axis == 'x' and position == 'bottom':
                    lines.append(
                        f"_bump = ({_fmt(m_height)} + {_fmt(m_pad)}) / _fig_h")
                    lines.append("_y0 += _bump; _h -= _bump")
                elif axis == 'y' and position == 'right':
                    lines.append(
                        f"_w -= ({_fmt(m_height)} + {_fmt(m_pad)}) / _fig_w")
                elif axis == 'y' and position == 'left':
                    lines.append(
                        f"_bump = ({_fmt(m_height)} + {_fmt(m_pad)}) / _fig_w")
                    lines.append("_x0 += _bump; _w -= _bump")
            lines.append(f"{p_var}.set_position([_x0, _y0, _w, _h])")

        # Now create each marginal axes in the freed space
        for m_ax, info in _marg_infos:
            parent_idx = info.get('parent_ax_index', 0)
            axis = info.get('axis', 'x')
            position = info.get('position', 'top' if axis == 'x' else 'right')
            m_height = info.get('height', 0.8)
            m_pad = info.get('pad', 0.05)
            mode = info.get('mode', 'overlay')
            n_bins = info.get('bins', 20)
            alpha = info.get('alpha', 0.5)
            separation = info.get('separation', 0.1)
            inverted = info.get('inverted', False)
            tick_side = info.get('tick_side',
                                'left' if axis == 'x' else 'bottom')
            tick_fs = info.get('tick_fontsize', 8)
            tick_step = info.get('tick_step', 0)
            range_min = info.get('range_min', 0)
            range_max = info.get('range_max', 0)
            label = info.get('label', '')
            label_fs = info.get('label_fontsize', 8)
            label_bold = info.get('label_bold', False)
            label_italic = info.get('label_italic', False)
            label_color = info.get('label_color', '#000000')
            m_title = info.get('title', '')
            title_fs = info.get('title_fontsize', 8)
            title_bold = info.get('title_bold', False)
            title_italic = info.get('title_italic', False)
            title_color = info.get('title_color', '#000000')
            colls = info.get('collections', [])
            share = 'sharex' if axis == 'x' else 'sharey'
            data_col = 0 if axis == 'x' else 1
            p_var = f"axes[{parent_idx}]" if multi else "ax"

            # Collect data + compute global bins
            data_exprs = []
            colors = []
            for ci in colls:
                idx = ci['coll_index']
                data_exprs.append(
                    f"{p_var}.collections[{idx}].get_offsets()[:, {data_col}]")
                colors.append(ci['color'])

            lines.append(
                f"_m_data = [{', '.join(data_exprs)}]")
            lines.append(
                f"_m_bins = np.histogram_bin_edges("
                f"np.concatenate(_m_data), bins={_fmt(n_bins)})")

            # Compute rect from adjusted main axes position
            lines.append(f"_pos = {p_var}.get_position()")
            lines.append("_fig_w, _fig_h = fig.get_size_inches()")
            if axis == 'x':
                lines.append(
                    f"_h_frac = {_fmt(m_height)} / _fig_h")
                lines.append(
                    f"_pad = {_fmt(m_pad)} / _fig_h")
                if position == 'top':
                    lines.append(
                        "_m_rect = [_pos.x0, _pos.y1 + _pad, "
                        "_pos.width, _h_frac]")
                else:
                    lines.append(
                        "_m_rect = [_pos.x0, _pos.y0 - _h_frac - _pad, "
                        "_pos.width, _h_frac]")
            else:
                lines.append(
                    f"_w_frac = {_fmt(m_height)} / _fig_w")
                lines.append(
                    f"_pad = {_fmt(m_pad)} / _fig_w")
                if position == 'right':
                    lines.append(
                        "_m_rect = [_pos.x1 + _pad, _pos.y0, "
                        "_w_frac, _pos.height]")
                else:
                    lines.append(
                        "_m_rect = [_pos.x0 - _w_frac - _pad, _pos.y0, "
                        "_w_frac, _pos.height]")

            lines.append(
                f"ax_m = fig.add_axes(_m_rect, {share}={p_var})")

            if mode == 'overlay':
                for i, color in enumerate(colors):
                    orient = (", orientation='horizontal'"
                              if axis == 'y' else "")
                    lines.append(
                        f"ax_m.hist(_m_data[{i}], bins=_m_bins, "
                        f"color={_fmt(color)}, alpha={_fmt(alpha)}, "
                        f"edgecolor='none'{orient})")
            else:  # dodge
                n = len(colls)
                lines.append(f"_n = {n}")
                lines.append(f"_bw = _m_bins[1] - _m_bins[0]")
                lines.append(f"_sub = _bw / _n")
                lines.append(
                    f"_bar = _sub * {_fmt(1 - separation)}")
                lines.append(
                    f"_ctrs = (_m_bins[:-1] + _m_bins[1:]) / 2")
                if axis == 'x':
                    lines.append(
                        f"for _i, (_d, _c) in enumerate("
                        f"zip(_m_data, {colors!r})):")
                    lines.append(
                        f"    _cnt, _ = np.histogram(_d, bins=_m_bins)")
                    lines.append(
                        f"    _off = _sub * (_i - (_n - 1) / 2)")
                    lines.append(
                        f"    ax_m.bar(_ctrs + _off, _cnt, width=_bar, "
                        f"color=_c, alpha={_fmt(alpha)}, edgecolor='none')")
                else:  # y
                    lines.append(
                        f"for _i, (_d, _c) in enumerate("
                        f"zip(_m_data, {colors!r})):")
                    lines.append(
                        f"    _cnt, _ = np.histogram(_d, bins=_m_bins)")
                    lines.append(
                        f"    _off = _sub * (_i - (_n - 1) / 2)")
                    lines.append(
                        f"    ax_m.barh(_ctrs + _off, _cnt, height=_bar, "
                        f"color=_c, alpha={_fmt(alpha)}, edgecolor='none')")

            # Inversion
            if inverted:
                if axis == 'x':
                    lines.append("ax_m.invert_yaxis()")
                else:
                    lines.append("ax_m.invert_xaxis()")

            # Spines
            for spine_name in ('top', 'right', 'bottom', 'left'):
                if not m_ax.spines[spine_name].get_visible():
                    lines.append(
                        f"ax_m.spines[{_fmt(spine_name)}].set_visible(False)")

            # Tick configuration
            _tfs = _fmt(tick_fs)
            if axis == 'x':
                lines.append(
                    "ax_m.tick_params(axis='x', bottom=False, top=False, "
                    "labelbottom=False, labeltop=False)")
                if tick_side == 'left':
                    lines.append(
                        f"ax_m.tick_params(axis='y', left=True, "
                        f"labelleft=True, right=False, labelright=False, "
                        f"labelsize={_tfs})")
                elif tick_side == 'right':
                    lines.append(
                        f"ax_m.tick_params(axis='y', left=False, "
                        f"labelleft=False, right=True, labelright=True, "
                        f"labelsize={_tfs})")
                else:
                    lines.append(
                        "ax_m.tick_params(axis='y', left=False, "
                        "labelleft=False, right=False, labelright=False)")
            else:
                lines.append(
                    "ax_m.tick_params(axis='y', left=False, right=False, "
                    "labelleft=False, labelright=False)")
                if tick_side == 'bottom':
                    lines.append(
                        f"ax_m.tick_params(axis='x', bottom=True, "
                        f"labelbottom=True, top=False, labeltop=False, "
                        f"labelsize={_tfs})")
                elif tick_side == 'top':
                    lines.append(
                        f"ax_m.tick_params(axis='x', bottom=False, "
                        f"labelbottom=False, top=True, labeltop=True, "
                        f"labelsize={_tfs})")
                else:
                    lines.append(
                        "ax_m.tick_params(axis='x', bottom=False, "
                        "labelbottom=False, top=False, labeltop=False)")

            # Tick step
            if tick_step > 0:
                count_axis = 'yaxis' if axis == 'x' else 'xaxis'
                lines.append(
                    f"ax_m.{count_axis}.set_major_locator("
                    f"matplotlib.ticker.MultipleLocator({_fmt(tick_step)}))")

            # Range (count-axis limits)
            if range_max > 0:
                if axis == 'x':
                    if inverted:
                        lines.append(
                            f"ax_m.set_ylim({_fmt(range_max)}, "
                            f"{_fmt(range_min)})")
                    else:
                        lines.append(
                            f"ax_m.set_ylim({_fmt(range_min)}, "
                            f"{_fmt(range_max)})")
                else:
                    if inverted:
                        lines.append(
                            f"ax_m.set_xlim({_fmt(range_max)}, "
                            f"{_fmt(range_min)})")
                    else:
                        lines.append(
                            f"ax_m.set_xlim({_fmt(range_min)}, "
                            f"{_fmt(range_max)})")

            # Label
            if label:
                _lfs = _fmt(label_fs)
                _lw = "'bold'" if label_bold else "'normal'"
                _ls = "'italic'" if label_italic else "'normal'"
                _lc_arg = ""
                if label_color != '#000000':
                    _lc_arg = f", color={_fmt(label_color)}"
                if axis == 'x':
                    if tick_side == 'right':
                        lines.append(
                            "ax_m.yaxis.set_label_position('right')")
                    lines.append(
                        f"ax_m.set_ylabel({_fmt(label)}, fontsize={_lfs}, "
                        f"fontweight={_lw}, fontstyle={_ls}{_lc_arg})")
                else:
                    if tick_side == 'top':
                        lines.append(
                            "ax_m.xaxis.set_label_position('top')")
                    lines.append(
                        f"ax_m.set_xlabel({_fmt(label)}, fontsize={_lfs}, "
                        f"fontweight={_lw}, fontstyle={_ls}{_lc_arg})")

            # Title
            if m_title:
                _tifs = _fmt(title_fs)
                _tw = "'bold'" if title_bold else "'normal'"
                _ts = "'italic'" if title_italic else "'normal'"
                _tc_arg = ""
                if title_color != '#000000':
                    _tc_arg = f", color={_fmt(title_color)}"
                lines.append(
                    f"ax_m.set_title({_fmt(m_title)}, fontsize={_tifs}, "
                    f"fontweight={_tw}, fontstyle={_ts}{_tc_arg})")

    return "\n".join(lines)


def _bxp_stats_from_original(orig_stats, dinfo):
    """Convert original introspected box_stats to bxp-compatible format.

    The introspector stores stats with a 'median' key; bxp() expects 'med'.
    Using original stats avoids recomputing from reconstructed data, which
    would degrade the violin KDE shape (double reconstruction).
    """
    bxp_stats = []
    for s in orig_stats:
        med = s.get('med') or s.get('median', 0)
        stat = {
            'med': round(float(med), 4),
            'q1': round(float(s['q1']), 4),
            'q3': round(float(s['q3']), 4),
            'whislo': round(float(s['whislo']), 4),
            'whishi': round(float(s['whishi']), 4),
            'fliers': [round(float(f), 4) for f in s.get('fliers', [])],
        }
        if dinfo.get('notch', False):
            iqr = stat['q3'] - stat['q1']
            # Use raw_data length if available, else 100 as proxy
            stat['cilo'] = round(stat['med'] - 1.57 * iqr / 10, 4)
            stat['cihi'] = round(stat['med'] + 1.57 * iqr / 10, 4)
        bxp_stats.append(stat)
    return bxp_stats


def _compute_bxp_stats(raw_data, dinfo):
    """Compute bxp-compatible stats from raw data arrays."""
    bxp_stats = []
    for rd in raw_data:
        arr = np.asarray(rd, dtype=float)
        if len(arr) == 0:
            continue
        q1, med, q3 = np.percentile(arr, [25, 50, 75])
        iqr = q3 - q1
        wlo_d = arr[arr >= q1 - 1.5 * iqr]
        whi_d = arr[arr <= q3 + 1.5 * iqr]
        whislo = float(np.min(wlo_d)) if len(wlo_d) > 0 else float(q1)
        whishi = float(np.max(whi_d)) if len(whi_d) > 0 else float(q3)
        fliers = arr[(arr < whislo) | (arr > whishi)]
        stat = {
            'med': round(float(med), 4),
            'q1': round(float(q1), 4),
            'q3': round(float(q3), 4),
            'whislo': round(float(whislo), 4),
            'whishi': round(float(whishi), 4),
            'fliers': [round(float(f), 4) for f in fliers],
        }
        if dinfo.get('notch', False):
            n = len(arr)
            ci = 1.57 * iqr / np.sqrt(n) if n > 0 else 0
            stat['cilo'] = round(float(med) - ci, 4)
            stat['cihi'] = round(float(med) + ci, 4)
        bxp_stats.append(stat)
    return bxp_stats


def _emit_stats_var(lines, bxp_stats, group_idx, n_groups):
    """Emit the _stats variable assignment. Returns the variable name."""
    svar = f"_stats_{group_idx}" if n_groups > 1 else "_stats"
    lines.append(f"{svar} = [")
    for s in bxp_stats:
        lines.append(f"    {s!r},")
    lines.append(f"]")
    return svar


def _emit_bxp_call(lines, ax_var, dinfo, svar, positions, label,
                    group_idx, n_groups, orient, width, mode):
    """Emit ax.bxp() call using an already-defined stats variable."""
    box_width = width * 0.3 if 'violin' in mode else width
    is_vert = orient == "vertical"

    bxp_args = []
    pos_str = ", ".join(str(round(float(p), 4)) for p in positions)
    bxp_args.append(f"positions=[{pos_str}]")
    bxp_args.append(f"vert={is_vert}")
    bxp_args.append("patch_artist=True")
    bxp_args.append(f"widths={_fmt(box_width)}")
    if dinfo.get('notch', False):
        bxp_args.append("notch=True")
    if dinfo.get('show_mean', False):
        bxp_args.append("showmeans=True")
        bxp_args.append("meanline=True")
    flier_marker = dinfo.get('flier_marker', 'o')
    if not flier_marker:
        bxp_args.append("showfliers=False")

    # boxprops
    bp_kw = [
        f"facecolor={_fmt(dinfo.get('box_color', '#1f77b4'))}",
        f"edgecolor={_fmt(dinfo.get('box_edgecolor', '#000000'))}",
    ]
    blw = dinfo.get('box_lw', 1.0)
    if blw != 1.0:
        bp_kw.append(f"linewidth={_fmt(blw)}")
    ba = dinfo.get('box_alpha', 1.0)
    if ba != 1.0:
        bp_kw.append(f"alpha={_fmt(ba)}")
    if dinfo.get('box_hatch', ''):
        bp_kw.append(f"hatch={_fmt(dinfo['box_hatch'])}")
    bxp_args.append(f"boxprops=dict({', '.join(bp_kw)})")

    # medianprops
    mp_kw = [f"color={_fmt(dinfo.get('median_color', '#ff7f0e'))}"]
    mlw = dinfo.get('median_lw', 2.0)
    if mlw != 2.0:
        mp_kw.append(f"linewidth={_fmt(mlw)}")
    bxp_args.append(f"medianprops=dict({', '.join(mp_kw)})")

    # whiskerprops
    wp_kw = []
    ws = dinfo.get('whisker_style', '-')
    if ws != '-':
        wp_kw.append(f"linestyle={_fmt(ws)}")
    wlw = dinfo.get('whisker_lw', 1.0)
    if wlw != 1.0:
        wp_kw.append(f"linewidth={_fmt(wlw)}")
    if wp_kw:
        bxp_args.append(f"whiskerprops=dict({', '.join(wp_kw)})")

    # capprops
    cp_kw = []
    if wlw != 1.0:
        cp_kw.append(f"linewidth={_fmt(wlw)}")
    if cp_kw:
        bxp_args.append(f"capprops=dict({', '.join(cp_kw)})")

    # flierprops
    if flier_marker:
        fl_kw = [
            f"marker={_fmt(flier_marker)}",
            f"markersize={_fmt(dinfo.get('flier_size', 6.0))}",
            f"markerfacecolor={_fmt(dinfo.get('flier_color', '#000000'))}",
        ]
        bxp_args.append(f"flierprops=dict({', '.join(fl_kw)})")

    # meanprops
    if dinfo.get('show_mean', False):
        ms = dinfo.get('mean_style', '--')
        mc = dinfo.get('median_color', '#ff7f0e')
        bxp_args.append(
            f"meanprops=dict(linestyle={_fmt(ms)}, color={_fmt(mc)})")

    bvar = f"_bp_{group_idx}" if n_groups > 1 else "_bp"
    lines.append(f"{bvar} = {ax_var}.bxp({svar},")
    for k, arg in enumerate(bxp_args):
        comma = "," if k < len(bxp_args) - 1 else ")"
        lines.append(f"    {arg}{comma}")
    lines.append(f"{bvar}['boxes'][0].set_label({_fmt(label)})")


def _emit_data_from_stats(lines, svar, group_idx, n_groups):
    """Emit code to reconstruct approximate data from box stats.

    Returns the variable name holding the list of data arrays.
    Mirrors ``_reconstruct_data_from_stats`` in ``_introspect.py`` exactly
    (including fliers and adjusted sample counts) so the violin KDE shapes
    match the matplotly rendering.
    """
    raw_var = f"_raw_{group_idx}" if n_groups > 1 else "_raw"
    lines.append(
        f"# Approximate data from stats "
        f"(replace {raw_var} with your original data for best fidelity)")
    lines.append(f"{raw_var} = []")
    lines.append(f"for _s in {svar}:")
    lines.append(f"    _fl = _s.get('fliers', [])")
    lines.append(f"    _n = max(100 - len(_fl), 20)")
    lines.append(f"    _q = _n // 4")
    lines.append(f"    _rem = _n - 4 * _q")
    lines.append(f"    _rng = np.random.RandomState(42)")
    lines.append(f"    {raw_var}.append(np.concatenate([")
    lines.append(f"        _rng.uniform(_s['whislo'], _s['q1'], _q),")
    lines.append(f"        _rng.uniform(_s['q1'], _s['med'], _q),")
    lines.append(f"        _rng.uniform(_s['med'], _s['q3'], _q),")
    lines.append(f"        _rng.uniform(_s['q3'], _s['whishi'], _q + _rem),")
    lines.append(f"        np.array(_fl, dtype=float),")
    lines.append(f"    ]))")
    return raw_var


def _emit_violin(lines, ax_var, dinfo, raw_var, positions,
                 orient, width, mode, label):
    """Emit ax.violinplot() with full styling."""
    vc = dinfo.get('violin_color', '#1f77b4')
    vec = dinfo.get('violin_edgecolor', '#000000')
    va = dinfo.get('violin_alpha', 0.3)
    vi = dinfo.get('violin_inner', 'box')
    vw = width * 1.5
    is_vert = orient == "vertical"
    show_stats = (vi != 'none')
    pos_str = ", ".join(str(round(float(p), 4)) for p in positions)

    lines.append(f"_vp = {ax_var}.violinplot({raw_var},")
    lines.append(f"    positions=[{pos_str}],")
    lines.append(f"    widths={_fmt(vw)}, vert={is_vert},")
    lines.append(
        f"    showmeans=False, showmedians={show_stats}, "
        f"showextrema={show_stats})")
    lines.append(f"for _body in _vp['bodies']:")
    lines.append(f"    _body.set_facecolor({_fmt(vc)})")
    lines.append(f"    _body.set_edgecolor({_fmt(vec)})")
    lines.append(f"    _body.set_alpha({_fmt(va)})")
    if show_stats:
        lines.append(
            f"for _key in ('cmedians', 'cmins', 'cmaxes', 'cbars'):")
        lines.append(f"    if _key in _vp:")
        lines.append(f"        _vp[_key].set_color({_fmt(vec)})")
        lines.append(f"        _vp[_key].set_alpha(0.8)")
    # Legend label if violin is the primary plot component
    if 'box' not in mode:
        lines.append(f"_vp['bodies'][0].set_label({_fmt(label)})")


def _emit_jitter(lines, ax_var, dinfo, raw_var, positions,
                 orient, mode, label):
    """Emit ax.scatter() calls for jitter/strip plot."""
    jc = dinfo.get('jitter_color', '#1f77b4')
    ja = dinfo.get('jitter_alpha', 0.5)
    js = dinfo.get('jitter_size', 3.0)
    jm = dinfo.get('jitter_marker', 'o')
    jsp = dinfo.get('jitter_spread', 0.2)
    pos_str = ", ".join(str(round(float(p), 4)) for p in positions)
    is_vert = orient == "vertical"
    jitter_only = 'box' not in mode and 'violin' not in mode

    lines.append(f"_rng_j = np.random.RandomState(42)")
    lines.append(
        f"for _i, (_d, _pos) in enumerate("
        f"zip({raw_var}, [{pos_str}])):")
    lines.append(
        f"    _jitter = _rng_j.uniform("
        f"{_fmt(-jsp)}, {_fmt(jsp)}, len(_d))")
    x_expr = "_pos + _jitter" if is_vert else "_d"
    y_expr = "_d" if is_vert else "_pos + _jitter"
    kw_parts = [
        f"s={_fmt(js ** 2)}", f"c={_fmt(jc)}",
        f"alpha={_fmt(ja)}", f"marker={_fmt(jm)}", "zorder=3",
    ]
    if jitter_only:
        kw_parts.append(
            f"label=({_fmt(label)} if _i == 0 else '_nolegend_')")
    lines.append(
        f"    {ax_var}.scatter({x_expr}, {y_expr}, "
        f"{', '.join(kw_parts)})")


def _emit_dist_with_data(lines, ax_var, dist_infos, data_vars,
                         orient, width, n_groups):
    """Emit distribution code using the user's real data variable(s).

    No artist cleanup. No fabricated data. Uses ax.boxplot() and
    ax.violinplot() directly with the user's data variable.

    When len(data_vars) == n_groups, each group uses its own data_var
    directly (multi-call scenario).  When len(data_vars) == 1, a single
    data_var is sliced by index (single-call, multi-group scenario).
    """
    lines.append(f"\n# Distribution plot")

    multi_var = len(data_vars) == n_groups and n_groups > 1

    if not multi_var:
        # Single data variable — compute position-to-data-index mapping
        data_var = data_vars[0]
        all_orig_pos = []
        for di in dist_infos:
            all_orig_pos.extend(
                di.get('original_positions', di['positions']))
        all_orig_pos_sorted = sorted(set(all_orig_pos))
        pos_to_idx = {p: i for i, p in enumerate(all_orig_pos_sorted)}

    for dj, dinfo in enumerate(dist_infos):
        mode = dinfo.get('display_mode', 'box')
        label = dinfo.get('label', f'Group {dj}')
        positions = dinfo.get('positions', [])
        orig_pos = dinfo.get('original_positions', positions)

        dvar = f"_data_{dj}" if n_groups > 1 else "_data"
        lines.append(f"\n# {label}")

        if multi_var:
            # Each group has its own data variable — use directly
            lines.append(f"{dvar} = {data_vars[dj]}")
        else:
            # Single data variable — slice by index
            indices = [pos_to_idx[p] for p in orig_pos
                       if p in pos_to_idx]
            lines.append(
                f"{dvar} = [{data_var}[i] for i in {indices!r}]")

        # Violin (background)
        if 'violin' in mode:
            _emit_violin(lines, ax_var, dinfo, dvar, positions,
                         orient, width, mode, label)

        # Box
        if 'box' in mode:
            _emit_boxplot_call(lines, ax_var, dinfo, dvar, positions,
                               label, dj, n_groups, orient, width, mode)

        # Jitter
        if 'jitter' in mode:
            _emit_jitter(lines, ax_var, dinfo, dvar, positions,
                         orient, mode, label)


def _emit_boxplot_call(lines, ax_var, dinfo, data_var, positions,
                       label, group_idx, n_groups, orient, width, mode):
    """Emit ax.boxplot() call using real data (Apply path)."""
    box_width = width * 0.3 if 'violin' in mode else width
    is_vert = orient == "vertical"

    bp_args = []
    pos_str = ", ".join(str(round(float(p), 4)) for p in positions)
    bp_args.append(f"positions=[{pos_str}]")
    bp_args.append(f"vert={is_vert}")
    bp_args.append("patch_artist=True")
    bp_args.append(f"widths={_fmt(box_width)}")
    if dinfo.get('notch', False):
        bp_args.append("notch=True")
    if dinfo.get('show_mean', False):
        bp_args.append("showmeans=True")
        bp_args.append("meanline=True")
    flier_marker = dinfo.get('flier_marker', 'o')
    if not flier_marker:
        bp_args.append("showfliers=False")

    # boxprops
    bp_kw = [
        f"facecolor={_fmt(dinfo.get('box_color', '#1f77b4'))}",
        f"edgecolor={_fmt(dinfo.get('box_edgecolor', '#000000'))}",
    ]
    blw = dinfo.get('box_lw', 1.0)
    if blw != 1.0:
        bp_kw.append(f"linewidth={_fmt(blw)}")
    ba = dinfo.get('box_alpha', 1.0)
    if ba != 1.0:
        bp_kw.append(f"alpha={_fmt(ba)}")
    if dinfo.get('box_hatch', ''):
        bp_kw.append(f"hatch={_fmt(dinfo['box_hatch'])}")
    bp_args.append(f"boxprops=dict({', '.join(bp_kw)})")

    # medianprops
    mp_kw = [f"color={_fmt(dinfo.get('median_color', '#ff7f0e'))}"]
    mlw = dinfo.get('median_lw', 2.0)
    if mlw != 2.0:
        mp_kw.append(f"linewidth={_fmt(mlw)}")
    bp_args.append(f"medianprops=dict({', '.join(mp_kw)})")

    # whiskerprops
    wp_kw = []
    ws = dinfo.get('whisker_style', '-')
    if ws != '-':
        wp_kw.append(f"linestyle={_fmt(ws)}")
    wlw = dinfo.get('whisker_lw', 1.0)
    if wlw != 1.0:
        wp_kw.append(f"linewidth={_fmt(wlw)}")
    if wp_kw:
        bp_args.append(f"whiskerprops=dict({', '.join(wp_kw)})")

    # capprops
    cp_kw = []
    if wlw != 1.0:
        cp_kw.append(f"linewidth={_fmt(wlw)}")
    if cp_kw:
        bp_args.append(f"capprops=dict({', '.join(cp_kw)})")

    # flierprops
    if flier_marker:
        fl_kw = [
            f"marker={_fmt(flier_marker)}",
            f"markersize={_fmt(dinfo.get('flier_size', 6.0))}",
            f"markerfacecolor={_fmt(dinfo.get('flier_color', '#000000'))}",
        ]
        bp_args.append(f"flierprops=dict({', '.join(fl_kw)})")

    # meanprops
    if dinfo.get('show_mean', False):
        ms = dinfo.get('mean_style', '--')
        mc = dinfo.get('median_color', '#ff7f0e')
        bp_args.append(
            f"meanprops=dict(linestyle={_fmt(ms)}, color={_fmt(mc)})")

    bvar = f"_bp_{group_idx}" if n_groups > 1 else "_bp"
    lines.append(f"{bvar} = {ax_var}.boxplot({data_var},")
    for k, arg in enumerate(bp_args):
        comma = "," if k < len(bp_args) - 1 else ")"
        lines.append(f"    {arg}{comma}")
    lines.append(f"{bvar}['boxes'][0].set_label({_fmt(label)})")


def _emit_hist_merged(lines, ax_var, hist_infos, data_vars=None):
    """Emit merged histogram code.

    When *data_vars* are provided (Apply path — AST-extracted from the
    user's cell), emits an executable ``ax.hist()`` call that replaces
    the user's original separate calls (which get commented out by
    ``_close_apply``).  Returns ``True`` so the caller can skip the
    redundant style-only loop.

    Without *data_vars* (Copy / fallback), emits a comment template
    and returns ``False`` so the caller still emits style-only code.
    """
    ref = hist_infos[0]
    n_bins = ref.get('bins', 20)

    colors = []
    labels = []
    for hi in hist_infos:
        colors.append(hi.get('color', '#1f77b4'))
        labels.append(hi.get('label', f'Hist {len(labels)}'))

    histtype = ref.get('histtype', 'bar')
    orientation = ref.get('orientation', 'vertical')
    cumulative = ref.get('cumulative', False)
    mode = ref.get('mode', 'count')
    density = mode == 'density'
    rwidth = ref.get('rwidth', 0.8)
    ec = ref.get('edgecolor', '#000000')
    lw = ref.get('linewidth', 1.0)
    alpha = ref.get('alpha', 0.7)

    kw_parts = [f"bins={_fmt(n_bins)}", f"histtype={_fmt(histtype)}"]
    if density:
        kw_parts.append("density=True")
    if cumulative:
        kw_parts.append("cumulative=True")
    if orientation != 'vertical':
        kw_parts.append(f"orientation={_fmt(orientation)}")
    kw_parts.append(f"color={colors!r}")
    kw_parts.append(f"edgecolor={_fmt(ec)}")
    kw_parts.append(f"linewidth={_fmt(lw)}")
    kw_parts.append(f"alpha={_fmt(alpha)}")
    kw_parts.append(f"label={labels!r}")
    kw_parts.append(f"rwidth={_fmt(rwidth)}")

    have_vars = (data_vars
                 and len(data_vars) == len(hist_infos)
                 and all(not v.startswith('<') for v in data_vars))

    if have_vars:
        # --- Executable merged call (Apply path) ---
        data_list = ", ".join(data_vars)
        lines.append(f"\n{ax_var}.hist([{data_list}],")
        for k, kw in enumerate(kw_parts):
            comma = "," if k < len(kw_parts) - 1 else ")"
            lines.append(f"    {kw}{comma}")

        # Per-histogram post-style (hatch, differing edgecolors, etc.)
        ecs = [hi.get('edgecolor', ec) for hi in hist_infos]
        alphas = [hi.get('alpha', alpha) for hi in hist_infos]
        for i, hi in enumerate(hist_infos):
            fixups = []
            if ecs[i] != ec:
                fixups.append(f"_p.set_edgecolor({_fmt(ecs[i])})")
            if alphas[i] != alpha:
                fixups.append(f"_p.set_alpha({_fmt(alphas[i])})")
            hatch = hi.get('hatch', '')
            if hatch:
                fixups.append(f"_p.set_hatch({_fmt(hatch)})")
            if fixups:
                lines.append(f"for _p in {ax_var}.containers[{i}]:")
                for f in fixups:
                    lines.append(f"    {f}")
        return True  # skip style-only loop
    else:
        # --- Comment template (Copy / fallback) ---
        lines.append(
            f"\n# Merged histograms \u2014 replace your separate "
            f"ax.hist() calls with:")
        data_hint = ", ".join(f"<{lbl}>" for lbl in labels)
        lines.append(f"# {ax_var}.hist([{data_hint}],")
        for k, kw in enumerate(kw_parts):
            comma = "," if k < len(kw_parts) - 1 else ")"
            lines.append(f"#     {kw}{comma}")

        for i, hi in enumerate(hist_infos):
            hatch = hi.get('hatch', '')
            if hatch:
                lines.append(
                    f"# for _p in {ax_var}.containers[{i}]:")
                lines.append(f"#     _p.set_hatch({_fmt(hatch)})")
        return False  # emit style-only loop


def _emit_bar_errorbars(lines, ax_var, bar_infos, bar_bc_rel_idxs,
                        need_bar_cs):
    """Emit errorbar code for bar groups with show_errorbars=True."""
    for idx, bi in enumerate(bar_infos):
        if not bi.get('show_errorbars', False):
            continue

        label = bi.get('label', f'Bar {idx}')
        color = bi.get('errbar_color', bi.get('color', '#1f77b4'))
        alpha = bi.get('errbar_alpha', 1.0)
        lw = bi.get('errbar_linewidth', 1.5)
        capsize = bi.get('errbar_capsize', 3.0)
        ls = bi.get('errbar_linestyle', '-')
        orientation = bi.get('orientation', 'vertical')
        errbar_values = bi.get('errbar_values', None)

        if idx >= len(bar_bc_rel_idxs):
            continue
        bc_idx = bar_bc_rel_idxs[idx]

        # Emit BarContainer filter if needed
        if not need_bar_cs:
            lines.append(
                "\nfrom matplotlib.container import "
                "BarContainer as _BC")
            lines.append(
                f"_bar_cs = [c for c in {ax_var}.containers "
                f"if isinstance(c, _BC)]")
            need_bar_cs = True

        _bacc = f"_bar_cs[{bc_idx}]"
        lines.append(f"\n# Error bars: {label}")
        if orientation == 'horizontal':
            lines.append(
                f"_bx = np.array([p.get_width() for p in {_bacc}])")
            lines.append(
                f"_by = np.array([p.get_y() + p.get_height() / 2 "
                f"for p in {_bacc}])")
            if errbar_values is not None:
                lines.append(f"_berr = np.array({errbar_values!r})")
            else:
                lines.append(f"_berr = np.abs(_bx) * 0.1")
            eb_args = (
                f"_bx, _by, xerr=_berr, fmt='none', "
                f"ecolor={_fmt(color)}, elinewidth={_fmt(lw)}, "
                f"capsize={_fmt(capsize)}")
        else:
            lines.append(
                f"_bx = np.array([p.get_x() + p.get_width() / 2 "
                f"for p in {_bacc}])")
            lines.append(
                f"_by = np.array([p.get_height() for p in {_bacc}])")
            if errbar_values is not None:
                lines.append(f"_berr = np.array({errbar_values!r})")
            else:
                lines.append(f"_berr = np.abs(_by) * 0.1")
            eb_args = (
                f"_bx, _by, yerr=_berr, fmt='none', "
                f"ecolor={_fmt(color)}, elinewidth={_fmt(lw)}, "
                f"capsize={_fmt(capsize)}")

        if ls != '-':
            eb_args += f", linestyle={_fmt(ls)}"
        if alpha != 1.0:
            eb_args += f", alpha={_fmt(alpha)}"
        lines.append(f"{ax_var}.errorbar({eb_args})")


def _emit_heatmap(lines, ax_var, heatmap_infos):
    """Emit code for heatmap styling (cmap, norm, clim, etc.)."""
    for idx, info in enumerate(heatmap_infos):
        htype = info.get('heatmap_type', 'imshow')
        cmap = info.get('cmap', 'viridis')
        vmin = info.get('vmin')
        vmax = info.get('vmax')
        norm_type = info.get('norm_type', 'linear')
        alpha = info.get('alpha', 1.0)
        interp = info.get('interpolation')
        aspect = info.get('aspect')
        annot_enabled = info.get('annot_enabled', False)
        annot_fmt = info.get('annot_fmt', '.2f')
        annot_fontsize = info.get('annot_fontsize', 8.0)
        annot_color = info.get('annot_color', 'auto')
        grid_enabled = info.get('grid_enabled', False)
        grid_lw = info.get('grid_lw', 1.0)
        grid_color = info.get('grid_color', '#ffffff')
        data = info.get('data')

        lines.append(f"\n# Heatmap ({htype})")

        if htype == 'imshow':
            var = f"_im = {ax_var}.images[{idx}]"
            acc = "_im"
        else:
            var = f"_qm = {ax_var}.collections[{idx}]"
            acc = "_qm"
        lines.append(var)

        lines.append(f"{acc}.set_cmap({_fmt(cmap)})")

        if norm_type == 'log':
            _vmin = max(vmin, 1e-10) if vmin is not None else 1e-10
            lines.append(
                f"from matplotlib.colors import LogNorm")
            lines.append(
                f"{acc}.set_norm(LogNorm("
                f"vmin={_fmt(_vmin)}, vmax={_fmt(vmax)}))")
        elif norm_type == 'symlog':
            lines.append(
                f"from matplotlib.colors import SymLogNorm")
            lines.append(
                f"{acc}.set_norm(SymLogNorm("
                f"linthresh=1.0, vmin={_fmt(vmin)}, vmax={_fmt(vmax)}))")
        elif norm_type == 'centered':
            lines.append(
                f"from matplotlib.colors import CenteredNorm")
            lines.append(
                f"{acc}.set_norm(CenteredNorm(vcenter=0))")
        else:
            lines.append(
                f"{acc}.set_clim({_fmt(vmin)}, {_fmt(vmax)})")

        if htype == 'imshow' and interp:
            lines.append(f"{acc}.set_interpolation({_fmt(interp)})")

        if htype == 'imshow' and aspect and str(aspect) != 'equal':
            lines.append(f"{ax_var}.set_aspect({_fmt(str(aspect))})")

        if alpha is not None and round(alpha, 2) != 1.0:
            lines.append(f"{acc}.set_alpha({_fmt(alpha)})")

        # Annotations
        if annot_enabled and data is not None:
            data_arr = np.asarray(data)
            if data_arr.ndim >= 2:
                nrows, ncols = data_arr.shape
                lines.append(f"\n# Annotations")
                lines.append(f"_data = {acc}.get_array()")
                lines.append(f"if hasattr(_data, 'reshape'):")
                lines.append(f"    _data = _data.reshape({nrows}, {ncols})")
                lines.append(f"_vmin, _vmax = {acc}.get_clim()")
                lines.append(f"_vmid = (_vmin + _vmax) / 2.0")
                lines.append(f"for _i in range({nrows}):")
                lines.append(f"    for _j in range({ncols}):")
                lines.append(f"        _val = _data[_i, _j]")
                if annot_color == 'auto':
                    lines.append(
                        f"        _c = 'white' if _val > _vmid else 'black'")
                else:
                    lines.append(f"        _c = {_fmt(annot_color)}")
                lines.append(
                    f"        {ax_var}.text(_j, _i, "
                    f"format(_val, {_fmt(annot_fmt)}), "
                    f"ha='center', va='center', "
                    f"fontsize={_fmt(annot_fontsize)}, color=_c)")

        # Grid
        if grid_enabled and data is not None:
            data_arr = np.asarray(data)
            if data_arr.ndim >= 2:
                nrows, ncols = data_arr.shape
                lines.append(f"\n# Grid lines")
                lines.append(
                    f"{ax_var}.set_xticks("
                    f"np.arange(-0.5, {ncols}, 1), minor=True)")
                lines.append(
                    f"{ax_var}.set_yticks("
                    f"np.arange(-0.5, {nrows}, 1), minor=True)")
                lines.append(
                    f"{ax_var}.grid(which='minor', "
                    f"color={_fmt(grid_color)}, "
                    f"linewidth={_fmt(grid_lw)}, linestyle='-')")
                lines.append(
                    f"{ax_var}.tick_params(which='minor', length=0)")

        # Tick labels
        xtick_show = info.get('xtick_show', True)
        ytick_show = info.get('ytick_show', True)
        xtick_labels_str = info.get('xtick_labels', '')
        ytick_labels_str = info.get('ytick_labels', '')

        if not xtick_show or not ytick_show or xtick_labels_str or ytick_labels_str:
            lines.append(f"\n# Tick labels")

        if not xtick_show:
            lines.append(
                f"{ax_var}.tick_params(axis='x', "
                f"bottom=False, labelbottom=False)")
        elif xtick_labels_str.strip():
            labels = [l.strip() for l in xtick_labels_str.split(',')]
            positions = list(range(len(labels)))
            lines.append(f"{ax_var}.set_xticks({positions})")
            lines.append(f"{ax_var}.set_xticklabels({labels!r})")

        if not ytick_show:
            lines.append(
                f"{ax_var}.tick_params(axis='y', "
                f"left=False, labelleft=False)")
        elif ytick_labels_str.strip():
            labels = [l.strip() for l in ytick_labels_str.split(',')]
            positions = list(range(len(labels)))
            lines.append(f"{ax_var}.set_yticks({positions})")
            lines.append(f"{ax_var}.set_yticklabels({labels!r})")


def _emit_colorbar(lines, ax_var, cbar_info, heatmap_infos):
    """Emit colorbar creation code."""
    htype = heatmap_infos[0].get('heatmap_type', 'imshow')
    if htype == 'imshow':
        mappable_var = f"{ax_var}.images[0]"
    else:
        mappable_var = f"{ax_var}.collections[0]"

    loc = cbar_info.get('location', 'right')
    shrink = cbar_info.get('shrink', 1.0)
    pad = cbar_info.get('pad', 0.05)
    label = cbar_info.get('label', '')
    label_fs = cbar_info.get('label_fontsize', 12.0)
    tick_fs = cbar_info.get('tick_fontsize', 10.0)

    lines.append(f"\n# Colorbar")

    # When location/shrink/pad differ from defaults, must remove + recreate
    needs_recreate = (loc != 'right'
                      or round(shrink, 2) != 1.0
                      or round(pad, 2) != 0.05)

    if needs_recreate:
        lines.append(
            f"if getattr({mappable_var}, 'colorbar', None) is not None:")
        lines.append(f"    {mappable_var}.colorbar.remove()")
        cbar_args = [f"{mappable_var}", f"ax={ax_var}"]
        if loc != 'right':
            cbar_args.append(f"location={_fmt(loc)}")
        if round(shrink, 2) != 1.0:
            cbar_args.append(f"shrink={_fmt(shrink)}")
        if round(pad, 2) != 0.05:
            cbar_args.append(f"pad={_fmt(pad)}")
        lines.append(f"_cbar = fig.colorbar({', '.join(cbar_args)})")
    else:
        # Reuse existing colorbar when possible (avoids remove/recreate)
        lines.append(
            f"_cbar = getattr({mappable_var}, 'colorbar', None)")
        lines.append(f"if _cbar is None:")
        lines.append(
            f"    _cbar = fig.colorbar({mappable_var}, ax={ax_var})")
        lines.append(f"else:")
        lines.append(f"    _cbar.update_normal({mappable_var})")

    if label:
        lines.append(
            f"_cbar.set_label({_fmt(label)}, fontsize={_fmt(label_fs)})")
    if round(tick_fs, 1) != 10.0:
        lines.append(f"_cbar.ax.tick_params(labelsize={_fmt(tick_fs)})")


def _emit_errorbars(lines, ax_var, errorbar_infos):
    """Emit code for errorbar styling.

    Always uses ErrorbarContainer (ax.errorbar()). Four toggles control
    visibility: error bars, markers, connecting line, shaded region.
    Each section has its own color.
    """
    for idx, info in enumerate(errorbar_infos):
        show_bars = info.get('show_bars', True)
        show_line = info.get('show_line', True)
        show_markers = info.get('show_markers', False)
        show_shaded = info.get('show_shaded', False)
        bar_color = info.get('bar_color', info.get('color', '#1f77b4'))
        marker_color = info.get('marker_color', bar_color)
        line_color = info.get('line_color', bar_color)
        shade_color = info.get('shade_color', bar_color)
        bar_alpha = info.get('bar_alpha', 1.0)
        marker_alpha = info.get('marker_alpha', 1.0)
        line_alpha = info.get('line_alpha', 1.0)
        lw = info.get('line_width', 1.5)
        ls = info.get('line_style', '-')
        bar_lw = info.get('bar_lw', 1.5)
        cap_size = info.get('cap_size', 3.0)
        marker = info.get('marker', '')
        marker_size = info.get('marker_size', 6.0)
        label = info.get('label', f'Errorbar {idx}')

        lines.append(f"\n# Errorbar: {label}")

        # Find the ErrorbarContainer by index
        lines.append(
            f"from matplotlib.container import "
            f"ErrorbarContainer as _EBC")
        lines.append(
            f"_eb_containers = [c for c in {ax_var}.containers "
            f"if isinstance(c, _EBC)]")
        lines.append(f"_eb = _eb_containers[{idx}]")

        # Data line styling
        lines.append(f"if _eb[0] is not None:")
        if show_line:
            lines.append(f"    _eb[0].set_color({_fmt(line_color)})")
            lines.append(f"    _eb[0].set_linewidth({_fmt(lw)})")
            lines.append(f"    _eb[0].set_linestyle({_fmt(ls)})")
            if line_alpha != 1.0:
                lines.append(
                    f"    _eb[0].set_alpha({_fmt(line_alpha)})")
        else:
            lines.append(f"    _eb[0].set_linestyle('none')")
            lines.append(f"    _eb[0].set_linewidth(0)")
        if show_markers and marker and marker not in ('', 'None', 'none'):
            lines.append(f"    _eb[0].set_marker({_fmt(marker)})")
            lines.append(
                f"    _eb[0].set_markersize({_fmt(marker_size)})")
            if marker_alpha != 1.0:
                # Apply marker alpha via RGBA to avoid affecting line
                lines.append(
                    f"    import matplotlib.colors as _mc")
                lines.append(
                    f"    _mkr_rgba = list("
                    f"_mc.to_rgba({_fmt(marker_color)}))")
                lines.append(
                    f"    _mkr_rgba[3] = {_fmt(marker_alpha)}")
                lines.append(
                    f"    _eb[0].set_markerfacecolor(_mkr_rgba)")
                lines.append(
                    f"    _eb[0].set_markeredgecolor(_mkr_rgba)")
            else:
                lines.append(
                    f"    _eb[0].set_markerfacecolor("
                    f"{_fmt(marker_color)})")
                lines.append(
                    f"    _eb[0].set_markeredgecolor("
                    f"{_fmt(marker_color)})")

        # Cap lines
        lines.append(f"for _cap in _eb[1]:")
        lines.append(f"    _cap.set_color({_fmt(bar_color)})")
        if show_bars:
            if cap_size > 0:
                lines.append(
                    f"    _cap.set_markersize({_fmt(cap_size)})")
        else:
            lines.append(f"    _cap.set_markersize(0)")
        if bar_alpha != 1.0:
            lines.append(f"    _cap.set_alpha({_fmt(bar_alpha)})")

        # Bar line collections
        lines.append(f"for _bar in _eb[2]:")
        lines.append(f"    _bar.set_color({_fmt(bar_color)})")
        if show_bars:
            lines.append(f"    _bar.set_linewidth({_fmt(bar_lw)})")
        else:
            lines.append(f"    _bar.set_linewidth(0)")
        if bar_alpha != 1.0:
            lines.append(f"    _bar.set_alpha({_fmt(bar_alpha)})")

        # Shaded region — create fill_between from bar segment data
        if show_shaded and info.get('has_yerr', False):
            shade_alpha = info.get('shade_alpha', 0.3)
            lines.append(f"_segs = _eb[2][0].get_segments()")
            lines.append(f"if _segs:")
            lines.append(
                f"    _x_s = np.array([s[0][0] for s in _segs])")
            lines.append(
                f"    _y_lo = np.array([s[0][1] for s in _segs])")
            lines.append(
                f"    _y_hi = np.array([s[1][1] for s in _segs])")
            lines.append(
                f"    {ax_var}.fill_between(_x_s, _y_lo, _y_hi, "
                f"color={_fmt(shade_color)}, "
                f"alpha={_fmt(shade_alpha)})")


def _fmt(val: Any) -> str:
    """Format a value as a Python literal."""
    if isinstance(val, bool):
        return repr(val)
    # Preserve integers (including numpy int types)
    import numbers
    if isinstance(val, numbers.Integral):
        return repr(int(val))
    # Handle numpy floats and regular floats
    try:
        f = float(val)
        return repr(round(f, 2))
    except (TypeError, ValueError):
        pass
    return repr(val)

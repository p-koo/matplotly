"""Generate Python code from the current figure state."""
from __future__ import annotations

from typing import Any

from matplotlib.colors import to_hex
from matplotlib.figure import Figure
from matplotlib.lines import Line2D

from ._commands import CommandStack


def generate_code(fig: Figure, stack: CommandStack) -> str:
    """Produce a Python code snippet reproducing the figure's current styling.

    Reads the live figure state directly so that all changes (including
    legend, tick_params, grid, etc.) are captured regardless of whether
    they went through the CommandStack.
    """
    axes_list = fig.get_axes()
    if not axes_list:
        return "# No axes found."

    multi = len(axes_list) > 1
    lines: list[str] = ["# Generated by matplotly"]

    for ax_i, ax in enumerate(axes_list):
        ax_var = f"axes[{ax_i}]" if multi else "ax"

        # --- Lines ---
        for i, line in enumerate(ax.lines):
            label = line.get_label()
            if label.startswith("_"):
                continue  # skip internal lines
            acc = f"{ax_var}.lines[{i}]"
            lines.append(f"\n# {label or f'Line {i}'}")
            lines.append(f"{acc}.set_color({_fmt(to_hex(line.get_color()))})")
            lines.append(f"{acc}.set_linewidth({_fmt(line.get_linewidth())})")
            ls = line.get_linestyle()
            if ls != "-":
                lines.append(f"{acc}.set_linestyle({_fmt(ls)})")
            alpha = line.get_alpha()
            if alpha is not None and alpha != 1.0:
                lines.append(f"{acc}.set_alpha({_fmt(alpha)})")
            marker = line.get_marker()
            if marker and marker != "None" and marker != "none":
                lines.append(f"{acc}.set_marker({_fmt(marker)})")
                lines.append(f"{acc}.set_markersize({_fmt(line.get_markersize())})")
            if label != line.get_label():
                lines.append(f"{acc}.set_label({_fmt(label)})")

        # --- Patches (bars, histograms) ---
        for i, patch in enumerate(ax.patches):
            if hasattr(patch, "get_facecolor"):
                fc = to_hex(patch.get_facecolor())
                if fc != "#1f77b4":  # only if non-default
                    acc = f"{ax_var}.patches[{i}]"
                    lines.append(f"{acc}.set_facecolor({_fmt(fc)})")

        # --- Collections (scatter) ---
        from matplotlib.collections import PathCollection
        for i, coll in enumerate(ax.collections):
            if not isinstance(coll, PathCollection):
                continue
            acc = f"{ax_var}.collections[{i}]"
            try:
                fc = coll.get_facecolor()
                if len(fc) > 0:
                    lines.append(f"{acc}.set_facecolor({_fmt(to_hex(fc[0]))})")
            except Exception:
                pass

        # --- Text labels ---
        title = ax.get_title()
        xlabel = ax.get_xlabel()
        ylabel = ax.get_ylabel()
        if title or xlabel or ylabel:
            lines.append(f"\n# Labels")
            if title:
                lines.append(f"{ax_var}.set_title({_fmt(title)})")
            if xlabel:
                lines.append(f"{ax_var}.set_xlabel({_fmt(xlabel)})")
            if ylabel:
                lines.append(f"{ax_var}.set_ylabel({_fmt(ylabel)})")

        # --- Fonts ---
        title_size = ax.title.get_fontsize()
        xlabel_size = ax.xaxis.label.get_fontsize()
        ylabel_size = ax.yaxis.label.get_fontsize()
        title_family = ax.title.get_fontfamily()
        if isinstance(title_family, list):
            title_family = title_family[0] if title_family else "Arial"

        lines.append(f"\n# Fonts")
        lines.append(f"{ax_var}.title.set_fontsize({_fmt(title_size)})")
        lines.append(f"{ax_var}.title.set_fontfamily({_fmt(title_family)})")
        lines.append(f"{ax_var}.xaxis.label.set_fontsize({_fmt(xlabel_size)})")
        lines.append(f"{ax_var}.yaxis.label.set_fontsize({_fmt(ylabel_size)})")

        # Tick label font size (use first tick as representative)
        xticks = ax.get_xticklabels()
        yticks = ax.get_yticklabels()
        if xticks:
            tick_sz = xticks[0].get_fontsize()
            lines.append(f"{ax_var}.tick_params(labelsize={_fmt(tick_sz)})")

        # --- Tick params ---
        # Read from the actual tick objects
        xtick_objs = ax.xaxis.get_major_ticks()
        if xtick_objs:
            tick = xtick_objs[0]
            tick_line = tick.tick1line
            direction = "in" if tick_line.get_marker() == 2 else "out"
            # Check inout: tick2line visible means inout
            if tick.tick2line.get_visible() and not ax.spines["top"].get_visible():
                direction = "inout"
            tick_len = tick_line.get_markersize()
            tick_width = tick_line.get_markeredgewidth()
            lines.append(f"{ax_var}.tick_params(direction={_fmt(direction)}, "
                         f"length={_fmt(tick_len)}, width={_fmt(tick_width)})")

        # --- Tick spacing ---
        from matplotlib.ticker import MultipleLocator as _ML
        x_loc = ax.xaxis.get_major_locator()
        y_loc = ax.yaxis.get_major_locator()
        if isinstance(x_loc, _ML) or isinstance(y_loc, _ML):
            lines.append(f"from matplotlib.ticker import MultipleLocator")
            if isinstance(x_loc, _ML):
                xt = list(ax.get_xticks())
                if len(xt) >= 2:
                    step = round(xt[1] - xt[0], 6)
                    if step > 0:
                        lines.append(
                            f"{ax_var}.xaxis.set_major_locator("
                            f"MultipleLocator({_fmt(step)}))")
            if isinstance(y_loc, _ML):
                yt = list(ax.get_yticks())
                if len(yt) >= 2:
                    step = round(yt[1] - yt[0], 6)
                    if step > 0:
                        lines.append(
                            f"{ax_var}.yaxis.set_major_locator("
                            f"MultipleLocator({_fmt(step)}))")

        # --- Spines ---
        spine_changes = []
        for name in ("top", "right", "bottom", "left"):
            sp = ax.spines[name]
            if not sp.get_visible():
                spine_changes.append(
                    f"{ax_var}.spines[{_fmt(name)}].set_visible(False)")
            lw = sp.get_linewidth()
            if lw != 1.0:
                spine_changes.append(
                    f"{ax_var}.spines[{_fmt(name)}].set_linewidth({_fmt(lw)})")
        if spine_changes:
            lines.append(f"\n# Spines")
            lines.extend(spine_changes)

        # --- Grid ---
        # Check if grid lines are visible
        has_grid = any(gl.get_visible() for gl in ax.xaxis.get_gridlines())
        if has_grid:
            gl = ax.xaxis.get_gridlines()[0]
            lines.append(f"\n# Grid")
            lines.append(
                f"{ax_var}.grid(True, alpha={_fmt(gl.get_alpha() or 0.5)}, "
                f"linewidth={_fmt(gl.get_linewidth())}, "
                f"linestyle={_fmt(gl.get_linestyle())})")

        # --- Legend ---
        leg = ax.get_legend()
        if leg is not None:
            handles, labels = ax.get_legend_handles_labels()
            if handles:
                lines.append(f"\n# Legend")
                labels_repr = "[" + ", ".join(_fmt(l) for l in labels) + "]"

                # Get legend properties
                leg_kwargs = []
                try:
                    loc = leg._loc
                    # Map integer loc codes to strings
                    _loc_names = {
                        0: "best", 1: "upper right", 2: "upper left",
                        3: "lower left", 4: "lower right", 5: "right",
                        6: "center left", 7: "center right",
                        8: "lower center", 9: "upper center", 10: "center",
                    }
                    loc_str = _loc_names.get(loc, loc)
                    leg_kwargs.append(f"loc={_fmt(loc_str)}")
                except Exception:
                    pass

                frameon = leg.get_frame().get_visible()
                leg_kwargs.append(f"frameon={_fmt(frameon)}")

                fontsize = leg._fontsize
                if fontsize:
                    leg_kwargs.append(f"fontsize={_fmt(fontsize)}")

                ncols = leg._ncols
                if ncols != 1:
                    leg_kwargs.append(f"ncol={_fmt(ncols)}")

                # bbox_to_anchor — convert from display to axes-fraction coords.
                # A point bbox (width≈0) means bbox_to_anchor was explicitly set
                # (e.g. via position sliders). The default axes bbox has large
                # width/height in display coords, so we skip it.
                if hasattr(leg, "_bbox_to_anchor") and leg._bbox_to_anchor is not None:
                    try:
                        bbox = leg._bbox_to_anchor
                        if bbox.width < 1 and bbox.height < 1:
                            inv = ax.transAxes.inverted()
                            x_ax, y_ax = inv.transform((bbox.x0, bbox.y0))
                            leg_kwargs.append(
                                f"bbox_to_anchor=({_fmt(round(x_ax, 2))}, "
                                f"{_fmt(round(y_ax, 2))})")
                    except Exception:
                        pass

                kwargs_str = ", ".join(leg_kwargs)
                # Use handle references
                lines.append(f"handles, labels = {ax_var}.get_legend_handles_labels()")
                lines.append(f"for h, lbl in zip(handles, {labels_repr}):")
                lines.append(f"    h.set_label(lbl)")
                lines.append(f"{ax_var}.legend({kwargs_str})")

        # --- Layout ---
        w, h = fig.get_size_inches()
        dpi = fig.dpi
        lines.append(f"\n# Layout")
        lines.append(f"fig.set_size_inches({_fmt(round(w, 2))}, {_fmt(round(h, 2))})")
        if dpi != 100:
            lines.append(f"fig.set_dpi({_fmt(int(dpi))})")

        fc = to_hex(fig.get_facecolor())
        if fc != "#ffffff":
            lines.append(f"fig.set_facecolor({_fmt(fc)})")

    return "\n".join(lines)


def _fmt(val: Any) -> str:
    """Format a value as a Python literal."""
    if isinstance(val, bool):
        return repr(val)
    # Handle numpy floats and regular floats
    try:
        f = float(val)
        return repr(round(f, 2))
    except (TypeError, ValueError):
        pass
    return repr(val)
